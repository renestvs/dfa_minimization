//kate: tab-width 4; space-indent on; indent-width 4; replace-tabs on; eol unix;

from minimization     import minimize
from equivalence      import automataAreEquivalent
from automaton2json   import object2automaton
from infiniteLanguage import infiniteLanguage
from epsElimination   import epsElim

function evalAudeScript(s)
    try
        return eval("(function () {" + audescript.toJS("return (" + s + ")").code + "}())");
    catch e
        return e
    end try
end function

function doTests(testCorrect, testFailed, testFailInfo)
    let tests := {
        "1": automataAreEquivalent( // test minimization
            minimize(
                object2automaton({
                    "states": ["1", "4", "7"],
                    "finalStates": ["1", "2", "3", "5", "6"],
                    "transitions": [
                        ["1", "b", "4"],
                        ["1", "a", "2"],
                        ["4", "b", "4"],
                        ["4", "a", "5"],
                        ["7", "a", "7"],
                        ["7", "b", "7"],
                        ["2", "a", "3"],
                        ["2", "b", "5"],
                        ["3", "a", "3"],
                        ["3", "b", "6"],
                        ["5", "b", "7"],
                        ["5", "a", "6"],
                        ["6", "b", "7"],
                        ["6", "a", "6"]
                    ]
                })
            ),
            object2automaton({
                "states": ["{1}", "{4}", "{7}"],
                "finalStates": ["{1}", "{2,3}", "{5,6}"],
                "transitions": [
                    ["{1}", "b", "{4}"],
                    ["{1}", "a", "{2,3}"],
                    ["{4}", "b", "{4}"],
                    ["{4}", "a", "{5,6}"],
                    ["{7}", "a", "{7}"],
                    ["{7}", "b", "{7}"],
                    ["{2,3}", "a", "{2,3}"],
                    ["{2,3}", "b", "{5,6}"],
                    ["{5,6}", "b", "{7}"],
                    ["{5,6}", "a", "{5,6}"]
                ]
            })
        ),
        "2": (
            function () # test transition function
                let o := {
                    "states": ["1", "4", "7"],
                    "finalStates": ["1", "2", "3", "5", "6"],
                    "transitions": [
                        ["1", "b", "4"],
                        ["1", "a", "2"],
                        ["4", "b", "4"],
                        ["4", "a", "5"],
                        ["7", "a", "7"],
                        ["7", "b", "7"],
                        ["2", "a", "3"],
                        ["2", "b", "5"],
                        ["3", "a", "3"],
                        ["3", "b", "6"],
                        ["5", "b", "7"],
                        ["5", "a", "6"],
                        ["6", "b", "7"],
                        ["6", "a", "6"]
                    ]
                }

                let A := object2automaton(o)

                let f := A.getTransitionFunction(true)

                foreach transition in o.transitions do
                    if (
                        f(
                            aude.getValue(transition[0]),
                            aude.getValue(transition[1])
                        ) != aude.getValue(transition[2])
                    ) then
                        testFailInfo(
                            "2",
                            "f("
                                + transition[0]
                                + ", "
                                + transition[1]
                                + ") is "
                                + Set.prototype.elementToString(f(transition[0], transition[1]))
                                + " instead of "
                                + transition[2]
                        )
                        return false
                    end if
                done
                return true
            end function
        )(),
        "3": automataAreEquivalent(
            object2automaton({
                "states": ["1", "2", "4", "5"],
                "finalStates": ["3"],
                "transitions": [
                    ["1", "5", "4"],
                    ["1", "6", "3"],
                    ["2", "5", "5"],
                    ["2", "6", "3"],
                    ["4", "5", "2"],
                    ["4", "6", "4"],
                    ["5", "5", "5"],
                    ["5", "6", "5"],
                    ["3", "5", "4"],
                    ["3", "6", "3"]
                ]
            }),
            minimize(
                object2automaton({
                    "states": ["1", "2", "4", "5"],
                    "finalStates": ["3"],
                    "transitions": [
                        ["1", "5", "4"],
                        ["1", "6", "3"],
                        ["2", "5", "5"],
                        ["2", "6", "3"],
                        ["4", "5", "2"],
                        ["4", "6", "4"],
                        ["5", "5", "5"],
                        ["5", "6", "5"],
                        ["3", "5", "4"],
                        ["3", "6", "3"]
                    ]
                })
            )
        ),
        "4": evalAudeScript("(function() let go := {}; let f := function() return go; end function; let o := {'a':(f)(),'b':f}; return o.a = go and o.b = f end function)()"),
        "5": evalAudeScript("(function() const [a,b,c] := [1,2,3]; return a = 1 and b = 2 and c = 3 end function)()"),
        "6": (
            function ()
                try
                    eval(
                        audescript.toPureJS(
                            "(function() const [a,b,c] := [1,2,3]; a = 2; end function)()"
                        ).code
                    )
                catch e
                    return true
                end try

                return false
            end function
        )(),
#         "7":  evalAudeScript("(function() let [a,,c] := [1,2,3];return [a,c] end function)().toString() = '1,3'"),
        "8":  evalAudeScript("1 + 2 belongs to {3}"),
        "9":  evalAudeScript("3 belongs to {1} union {3}"),
        "10": evalAudeScript("(1,2,3) != (1,(2,3))"),
        "11": evalAudeScript("(1,2,3) = ((1,2),3)"),
        "12": evalAudeScript("{(1,2,3)} = {1} cross {2} cross {3}"),
        "13": evalAudeScript("1 belongs to {0,1} belongs to {true,false}"),
        "14": evalAudeScript("({3} contains 1 + 2) = true"),
        "15": evalAudeScript("({1} union {3} contains 1) = true"),
#         "16": evalAudeScript("((a, b) => a + b)(10, 32) = 42"),
#         "17": evalAudeScript("(a => a + 10)(32) = 42"),
        "18": evalAudeScript("1 = 2 or 1 = 1"),
        "19": evalAudeScript("{1,2,3,4} symDiff {3,4,5,6} = {1,2,5,6}"),
        "20": evalAudeScript("(function() let (a, b) := ((0 and 1) or [2, 3]); return a = 2 and b = 3 end function)()"),
        "21": evalAudeScript("(if 1 = 1 then if 2 = 2 then 3 else 2 else 1) = 3"),
        "22": evalAudeScript("(if 1 = 1 then if 2 = 3 then 3 else 2 else 1) = 2"),
        "23": evalAudeScript("(if 1 = 0 then if 2 = 2 then 3 else 2 else 1) = 1"),
#         "24": evalAudeScript("(x=>x+1)(0) === 1"), // dont touch spaces for this one please ;-)
        "25": evalAudeScript("{a:1,b:1} = {b:1,a:1}"),
        "26": evalAudeScript("{a:1,b:2} != {b:1,a:1}"),
        "27": evalAudeScript("[1,2,3] != [1,2]"),
        "28": infiniteLanguage(
                object2automaton(
                    {
                        "states": ["0","1","3","2"],
                        "finalStates": ["4"],
                        "transitions": [
                            ["0","a","1"],
                            ["0","a","3"],
                            ["1","a","2"],
                            ["3","a","1"],
                            ["2","a","3"],
                            ["2","a","4"]
                        ]
                    }
                )
              ) = true,
        "29": infiniteLanguage(
                object2automaton(
                    {
                        "states": ["0","1","3","2"],
                        "finalStates": ["0"],
                        "transitions": [
                            ["0","a","1"],
                            ["0","a","3"],
                            ["1","a","2"],
                            ["3","a","1"],
                            ["2","a","3"]
                        ]
                    }
                )
              ) = false,
        "30": infiniteLanguage(
                object2automaton(
                    {
                        "states": ["0","1","2"],
                        "finalStates": ["3"],
                        "transitions": [
                            ["0","a","1"],
                            ["0","a","3"],
                            ["1","a","2"],
                            ["2","a","0"],
                            ["3","a","2"]
                        ]
                    }
                )
              ) = true,
        "31": infiniteLanguage(
                object2automaton(
                    {
                        "states": ["0","3","2"],
                        "finalStates": ["1"],
                        "transitions": [
                            ["0","a","1"],
                            ["0","a","3"],
                            ["1","a","2"],
                            ["2","a","0"],
                            ["3","a","2"]
                        ]
                    }
                )
              ) = true,
        "32": automataAreEquivalent(
                minimize(
                    object2automaton(
                        {
                            "states": ["0","1","3","2"],
                            "finalStates": ["0"],
                            "transitions": [
                                ["0","a","1"],
                                ["0","a","3"],
                                ["1","a","2"],
                                ["3","a","1"],
                                ["2","a","3"]
                            ]
                        }
                    )
                ),
                object2automaton(
                    {
                        "states": ["0"],
                        "finalStates": ["0"],
                        "transitions": []
                    }
                )
             ),
        "33": automataAreEquivalent(
            epsElim(
                object2automaton(
                    {
                        "states": ["0","1"],
                        "finalStates": ["2"],
                        "transitions": [
                            ["0","a","0"],
                            ["0","\\e","1"],
                            ["1","b","1"],
                            ["1","\\e","2"],
                            ["2","c","2"]
                        ]
                    }
                )
            ),
            object2automaton(
                {
                    "states": ["0"],
                    "finalStates": ["0","2","1"],
                    "transitions": [
                        ["0","a","0"],
                        ["0","a","2"],
                        ["0","b","2"],
                        ["0","c","2"],
                        ["0","a","1"],
                        ["0","b","1"],
                        ["2","c","2"],
                        ["1","b","2"],
                        ["1","c","2"],
                        ["1","b","1"]
                    ]
                }
            )
        ),

        "34": automataAreEquivalent(
            object2automaton(
                {
                    "states": ["1","4","7"],
                    "finalStates": ["1","2","5","3","6"],
                    "transitions": [
                        ["1","b","4"],
                        ["1","a","2"],
                        ["4","b","4"],
                        ["4","a","5"],
                        ["7","a","7"],
                        ["7","b","7"],
                        ["2","a","3"],
                        ["2","b","5"],
                        ["3","a","3"],
                        ["3","b","6"],
                        ["5","b","7"],
                        ["5","a","6"],
                        ["6","b","7"],
                        ["6","a","6"]
                    ]
                }
            ),
            minimize(
                object2automaton(
                    {
                        "states": ["1","4","7"],
                        "finalStates": ["1","2","5","3","6"],
                        "transitions": [
                            ["1","b","4"],
                            ["1","a","2"],
                            ["4","b","4"],
                            ["4","a","5"],
                            ["7","a","7"],
                            ["7","b","7"],
                            ["2","a","3"],
                            ["2","b","5"],
                            ["3","a","3"],
                            ["3","b","6"],
                            ["5","b","7"],
                            ["5","a","6"],
                            ["6","b","7"],
                            ["6","a","6"]
                        ]
                    }
                )
            )
        )
    }

    let tryParse := [
        "automaton2json.ajs",
        "automaton2regex.ajs",
        "complementation.ajs",
        "completion.ajs",
        "determinization.ajs",
        "determinize.ajs",
        "differentiability.ajs",
        "emptyLanguage.ajs",
        "epsElim.ajs",
        "equivalence.ajs",
        "infiniteLanguage.ajs",
        "minimization.ajs",
        "mirror.ajs",
        "normalization.ajs",
        "product.ajs",
        "regex2automaton.ajs",
        "regex2minautomaton.ajs"
    ];

    function parse(fileNumber)
            getFile(
                "algos/" + tryParse[fileNumber],
                function(file)
                    let res := nil

                    try
                        eval(audescript.toJS(file).code)
                        res := "OK"
                    catch e
                        res := "Failed (" + e + ")\n" + e.stack
                    end try

                    audescript.console.log("Parsing " + t + ": " + res)

                    if tryParse[fileNumber + 1] then
                        parse(fileNumber + 1)
                    end if
                end function,
                function (err)
                    audescript.console.error(err)

                    if tryParse[fileNumber + 1] then
                        parse(fileNumber + 1)
                    end if
                end function
            )
    end function

    let success := true
    foreach (name, test) in tests do
        if test = true then
            testCorrect(name)
        else
            testFailed(name, if test is not false then test else null)
            success := false
        end if
    done

    return success
end function

function testCorrect(i)
    audescript.console.log("Test " + i + ": OK")
end function

function testFailed(i, e)
    audescript.console.log("Test " + i + ": Failed" + (if e then ", got : " + e else ""))
end function

function testFailInfo(n, s)
    audescript.console.log("Test " + n + ": info: " + s)
end function

run(
    (function()
        return if doTests(testCorrect, testFailed, testFailInfo) then "Success" else "Failure"
    end function),
)

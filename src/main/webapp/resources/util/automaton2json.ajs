let map := new Object
map["\\e"] := epsilon
map["Îµ"]   := epsilon

export function automaton2json(A)
    function toString(e)
        if e = epsilon then
            return "\\\\e"
        end if

        return JSON.stringify(Set.prototype.elementToString(e, map))
    end function

    let finalStates := A.getFinalStates()
    let states      := A.getStates()
    let transitions := A.getTransitions()
    let q_init      := A.getInitialState()
    let result      := "{\n\t\"states\": [" + toString(q_init)
    let began       := false


    foreach state in states do
        if state != q_init and finalStates does not contain state then
            result += "," + toString(state)
        end if
    done

    result += "],\n\t\"finalStates\": ["

    foreach state in finalStates do
        if began then
            result += ","
        else
            began := true
        end if
        result += toString(state)
    done

    result += "],\n\t\"transitions\": ["
    began  := false

    foreach transition in transitions do
        if began then
            result += ","
        else
            began := true
        end if

        result += "\n\t\t[" + toString(transition.startState) + "," + toString(transition.symbol) + "," + toString(transition.endState) + "]"
    done

    return result + "\n\t]\n}"
end function

export function object2automaton(o)
    let A := new Automaton

    let fromString := aude.getValue

    for i from 0 to o.states.length - 1 do
        if i = 0 then
            A.setInitialState(fromString(o.states[i], map))
        else
            A.addState(fromString(o.states[i], map))
        end if
    done

    foreach s in o.finalStates do
        A.addFinalState(fromString(s, map))
    done

    foreach t in o.transitions do
        A.addTransition(
            fromString(t[0], map),
            fromString(t[1], map),
            fromString(t[2], map)
        )
    done

    return A
end function

run(automaton2json, get_automaton(currentAutomaton))
